(ns miner.claude-max-non-adjacent)

;;; Solution generated by Claude.  Downloaded by SEM.  I tried to coach Claude to get the
;;; correct answers but our chat was cut off (too long?) before we got there.  He did
;;; improve a bit and seemed to understand my corrections.  Still, Claude did not get a
;;; correct answer in several cases so this is not reliable.  Also, Claude did not find the
;;; state machine approach which seems to be the best way to understand the real problem.
;;; His approach is to try all the possible gaps but that is going to be slow.

;;; SEM hacking on some Claude code.  Originals are preserved below.
;;; Claude was giving 0 for too short inputs, I prefer nil as the answer but that's OK.
;;; Claude's brute seems to work but it's slow.  On my test-mon, Claude's time is 4.8 ms,
;;; compared to my nice max-non-seg-sum at 4.0 us.  That's a factor of over 1000x.

(defn sem-max-non-segment-brute [nums]
  (let [n (count nums)]
    (when (>= n 3)
      (letfn [(has-proper-gap? [selection]
                ;; Check if selection has at least one internal gap
                (let [selected-positions (set selection)
                      min-pos (apply min selection)
                      max-pos (apply max selection)]
                  (and (> (count selection) 0)
                       (< min-pos max-pos)
                       (some #(not (selected-positions %)) 
                             (range (inc min-pos) max-pos)))))
              
              (all-subsets [s]
                (if (empty? s)
                  [#{}]
                  (let [rest-subsets (all-subsets (rest s))]
                    (concat rest-subsets
                            (map #(conj % (first s)) rest-subsets)))))]
        
        (->> (all-subsets (range n))
             (filter #(and (seq %) (has-proper-gap? %)))
             (map #(apply + (map (partial nth nums) %)))
             (apply max 0))))))


;;;;;; 06/02/25  17:53 by miner -- below here is code that Claude generated with a few
;;;;;; prompts and corrections by SEM.  Note, it is not completely correct.

;;; Good that Claude figured out that you need at least 3 elements in the input collection.
;;; Claude's Solution 1 will never work.
;;; By the way, Claude had a syntax error (missing closed square bracket in a let that had
;;; nested square brackets.  Easy enough fix so I just put it in.

;;;;;;----------------------------------------------------------------------

;; Maximal Non-Segment Sum Problem (Problem 11 from "Pearls of Functional Algorithm Design")
;; Find the maximum sum of selected elements such that there is at least one 
;; unselected element with selected elements on both sides (a proper gap)

;; The key insight: we need at least one gap, but we can select any elements
;; on either side of the gap. We just sum all selected elements.

;; Solution 1: Try all possible gap positions and select optimally around them
(defn max-non-segment-sum [nums]
  (let [n (count nums)]
    (if (< n 3) ; Need at least 3 elements for a proper gap
      0
      (letfn [(try-gap-at [gap-pos]
                ;; Force a gap at gap-pos, optimize selection on both sides
                (let [left-sum (apply + (filter pos? (take gap-pos nums)))
                      right-sum (apply + (filter pos? (drop (inc gap-pos) nums)))]
                  (+ left-sum right-sum)))]
        
        ;; Try gap at each internal position
        (apply max 0 (map try-gap-at (range 1 (dec n))))))))

;; Solution 2: More systematic - try all possible selections with required gap
(defn max-non-segment-brute [nums]
  (let [n (count nums)]
    (if (< n 3)
      0
      (letfn [(has-proper-gap? [selection]
                ;; Check if selection has at least one internal gap
                (let [selected-positions (set selection)
                      min-pos (apply min selection)
                      max-pos (apply max selection)]
                  (and (> (count selection) 0)
                       (< min-pos max-pos)
                       (some #(not (selected-positions %)) 
                             (range (inc min-pos) max-pos)))))
              
              (all-subsets [s]
                (if (empty? s)
                  [#{}]
                  (let [rest-subsets (all-subsets (rest s))]
                    (concat rest-subsets
                            (map #(conj % (first s)) rest-subsets)))))]
        
        (->> (all-subsets (range n))
             (filter #(and (seq %) (has-proper-gap? %)))
             (map #(apply + (map (partial nth nums) %)))
             (apply max 0))))))

;; Solution 3: Dynamic programming approach
;; For each gap position, decide what to take from left and right
(defn max-non-segment-dp [nums]
  (let [n (count nums)]
    (if (< n 3)
      0
      ;; For each possible gap position
      (apply max 0
             (for [gap (range 1 (dec n))]
               ;; Sum all positive elements on left and right of gap
               (+ (apply + (filter pos? (take gap nums)))
                  (apply + (filter pos? (drop (inc gap) nums)))))))))

;; Solution 4: More flexible - consider all elements but ensure gap constraint
(defn max-non-segment-flexible [nums]
  (let [n (count nums)]
    (if (< n 3)
      0
      ;; Try every possible way to partition into left, gap, right
      (apply max 0
             (for [gap-start (range 1 (dec n))
                   gap-end (range gap-start (dec n))]
               (+ ;; Take all positive from left part
                  (apply + (filter pos? (take gap-start nums)))
                  ;; Take all positive from right part  
                  (apply + (filter pos? (drop (inc gap-end) nums)))))))))

;; Solution 5: The correct approach - must have elements on both sides of gap
(defn max-non-segment-correct [nums]
  (let [n (count nums)]
    (if (< n 3)
      0
      (apply max 0
             (for [gap (range 1 (dec n))] ; Gap must be internal
               (let [left-part (take gap nums)
                     right-part (drop (inc gap) nums)]
                 ;; We must take at least something from both sides to have a proper gap
                 ;; But we can choose what to take to maximize sum
                 (max 0 ; In case everything is negative
                      (+ (apply + (filter pos? left-part))
                         (apply + (filter pos? right-part))))))))))

;; Test function
(defn test-solutions []
  (let [test-cases [
                    [1 100 1 100]                      ; Expected: 201
                    [5 1 3 9 2]                        
                    [1 2 3 4 5]                        
                    [10 -1 10]                         ; Expected: 20
                    [-1 -2 -3]                         ; All negative, expected: 0
                    [100]                              ; Single element, expected: 0
                    [1 2]                              ; Two elements, expected: 0  
                    [1 -5 2 -3 4]                      
                    [1 2 -1 3 4]                       
                    [-3 -4 3 4 5 6 7]                  ; Expected: 22 (gap at 1: [-3] + [3,4,5,6,7])
                    [-3 -4 3 4 5 6 7 -5 -1 -4 1]      ; Expected: 25  
                    [1 3 4 5 6 7 -5 -1 -4]]]           ; Expected: 25
        
    (doseq [test-case test-cases]
      (println (format "Input: %s" test-case))
      (println (format "  Solution 1: %d" (max-non-segment-sum test-case)))
      (println (format "  Brute Force: %d" (max-non-segment-brute test-case)))
      (println (format "  Correct: %d" (max-non-segment-correct test-case)))
      (println))))

;; Manual examples
(defn manual-examples []
  (println "Manual verification:")
  (println "")
  
  (println "[-3 -4 3 4 5 6 7] with gap at index 1:")
  (println "  Left: [-3], Right: [3 4 5 6 7]")  
  (println "  If we take negatives: -3 + 25 = 22")
  (println "  If we skip negatives: 0 + 25 = 25")
  (println "  But the problem might require taking something from both sides...")
  (println "")
  
  (println "[1 3 4 5 6 7 -5 -1 -4] - various gaps:")
  (println "  Gap at 6: [1 3 4 5 6 7] + [] = 26, but need both sides")
  (println "  Gap at 5: [1 3 4 5 6] + [-1 -4] = 19 + 0 = 19") 
  (println "  Need to find the right interpretation..."))

;; Run tests
(test-solutions)
  (manual-examples)
  
