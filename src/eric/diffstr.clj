(ns eric.diffstr)

;; https://gist.github.com/ericnormand/87c7c0804b2cde1a1a1e65caaf4c5296
;; String difference
;; 
;; Imagine two strings, A and B. B is generated by shuffling the letters in A and adding a new random letter to it at a random position. Write a function that takes A and B and returns the new letter.


(defn diff [astr bstr]
  (loop [sa (sort astr) sb (sort bstr)]
    (if (= (first sa) (first sb))
      (recur (rest sa) (rest sb))
      (first sb))))

;; almost as fast
(defn fdiff [a b]
  (reduce-kv (fn [_ c cnt] (when (odd? cnt) (reduced c)))
             nil
             (frequencies (str a b))))




;; works but not fast enough
(defn oddball
  ([]
   (fn [rf]
     (let [pv (volatile! ::none)]
       (fn
         ([] (rf))
         ([result] (let [prior @pv]
                     (if (= prior ::none)
                       (rf result)
                       (rf (rf result prior)))))
         ([result input]
            (let [prior @pv]
              (cond (= prior ::none) (do (vreset! pv input) result)
                    (= prior input) (do (vreset! pv ::none) result)
                    :else (do (vreset! pv input) (rf result prior)))))))))
  ([coll] (sequence (oddball) coll)))


(defn odiff [a b]
  (first (sequence (oddball) (sort (str a b)))))


;; not bad, but not great
(defn cdiff [a b]
  (let [res (reduce (fn [pv c]
                      (if (= c (peek pv))
                        (conj pv c)
                        (if (odd? (count pv))
                          (reduced (peek pv))
                          [c])))
                    []
                    (sort (str a b)))]
    (if (char? res)
      res
      (peek res))))


;; ok
(defn fdiff4 [a b]
  (first (sequence (keep (fn [[c cnt]] (when (odd? cnt) c))) (frequencies (str a b)))))


(defn fdiff42 [a b]
  (first (sequence (keep (fn [[c cnt]] (when (odd? cnt) c)))
                   (sort (str a b)))))


(defn fdiff5 [a b]
  (first (sequence (comp (map list)
                         (keep (fn [[a b]] (when (not= a b) b))))
                   (sort (str a (char 255)))
                   (sort b))))


;; my orig
(defn diff1 [astr bstr]
  #_ (assert (= (inc (count astr)) (count bstr)))
  (loop [sa (sort astr) sb (sort bstr)]
    (let [a (first sa)
          b (first sb)]
      (if (= a b)
        (recur (rest sa) (rest sb))
        b))))


(defn smoke-diff [diff]
  (assert (= (diff "" "j") \j))
  (assert (= (diff "a" "ab")  \b))
  (assert (= (diff "abc" "xcab") \x))
  (assert (= (diff "xxyyzz" "xzyfyxz") \f))
  (assert (= (diff "cccvv" "cvvcvc") \v))
  true)



;; @jonasseglare  slightly revised for better performance -- faster than mine
(defn jo-diff [before after]
  (let [char-sum (fn [s] (reduce (fn [sum c] (+ sum (int c))) 0 s))]
    (char (- (char-sum after)
             (char-sum before)))))

;; .getBytes doesn't perform any better, at least for my test strings which are fairly short.

;; sem revised -- fast
(defn jo-diff2 [before after]
  (char (reduce (fn [r c] (bit-xor r (int c))) 0 (str before after))))

;; fastest trans, based on the @jonasseglare bit-xor, OK but not especially fast
(defn xdiff [before after]
  (transduce (map int)
             (completing bit-xor char)
             0
             (str before after)))

